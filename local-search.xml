<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机算法-6</title>
    <link href="/2025/01/07/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-6/"/>
    <url>/2025/01/07/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-6/</url>
    
    <content type="html"><![CDATA[<h1 id="分支限界法">分支限界法</h1><ul><li>什么是分支限界法？<ul><li>以广度优先或以最小耗费优先的方式搜索解空间树<strong>，</strong>找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。也是以树形结构（子集树或排列树）来组织解空间</li><li>分支限界的解空间比回溯法要大得多。内存有限时，使用回溯法更容易成功</li><li>常规思路：<ul><li>在分支限界法中，每个活结点只有一次机会成为扩展节点。一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子节点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一节点成为当前扩展结点，并重复上述扩展过程。这个过程一直持续到找到所需解或活结点表为空时为止。</li></ul></li><li>常见的分支限界法：<ul><li>队列式分支限界法（FIFO）：按照队列先进先出原则选取下一个节点作为扩展节点</li><li>优先队列式分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展结点。==该方法最大收益、最小损耗==</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>分支限界法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机算法-5</title>
    <link href="/2025/01/07/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-5/"/>
    <url>/2025/01/07/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-5/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯法">回溯法</h1><ul><li><p>什么是回溯法？</p><ul><li><p>常用于对候选解进行系统检查的方法</p><ul><li>回溯和分支限定（定界）</li></ul></li><li><p>常规思路：</p><ul><li>列出所有候选解</li><li>依次检查每一个解，直到找到所需的解</li><li>避免无效的搜索：<ul><li>剪枝函数：<ul><li>约束函数：在扩展结点（当前正在搜索的节点）处剪去不满足约束条件的子树</li><li>限界函数：剪去不能得到最优解的子树</li></ul></li></ul></li></ul></li><li><p>可行性前提：</p><ul><li>候选解的数量有限</li><li>能够通过检查所有或部分候选解得到所需的解</li></ul></li><li><p>回溯法中的两种常见解空间树：</p><ul><li>子集树：当所给的问题是从n个元素组成的集合S中找出满足某种性质的一个子集时，相应的解空间树称为子集树。典型案例，0-1背包问题<ul><li>当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树为子集树。这类子集树常有<span class="math inline">\(2^n\)</span>个叶结点，其结点个数为<span class="math inline">\(2^{n+1}-1\)</span>。遍历子集树的任何算法均需<span class="math inline">\(Ω(2^n)\)</span>的计算时间。（如背包问题）</li></ul></li><li>排列树：当所给的问题是从n个元素的排列中找出某种性质的一个排列时，相应的解空间树称为排列树。典型案例：n后问题<ul><li>当所给问题是确定n个元素的满足某种性质的排列时，相应的解空间树为排列树。排列树通常有n!个叶结点。因此遍历排列树所需的计算时间需要Ω(n!)的计算时间。（如TSP问题）</li></ul></li></ul><p><img src="/2025/01/07/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-5/image-20250107154328455.png" alt="image-20250107154328455" style="zoom:67%;"></p></li></ul></li></ul><blockquote><p>回溯法的基本做法是在问题的解空间中，按照深度优先策略，从根节点出发搜索解空间树。当算法搜索到解空间树的任意节点时，先要判断该节点是否包含问题的解，如果不包含，则跳过以该节点为根的子树的搜索，逐层向其祖先节点会回溯。否则，进入该子树，继续按深度优先策略进行搜索。</p></blockquote><p><em>解空间树：不考虑任何条件，穷举所有情况的树结构，通常是一个满多叉树，但也可能不是，关键在于它列举了所有可能的情况。解空间树的每个节点代表了问题的一个潜在解，而整棵树则代表了所有可能的解的集合。</em></p><p><em>搜索空间树：在解空间树的基础上，通过减枝（剪枝）操作得到的树结构。减枝是一种优化搜索过程的方法，它通过剪去那些不可能产生最优解或满足条件的解的分支，从而减少搜索的范围和复杂度。搜索空间树的每个节点仍然代表问题的一个潜在解，但整棵树只包含了那些经过筛选的、可能是最优解或满足特定条件的解。</em></p><h2 id="迷宫问题">1、迷宫问题</h2><ul><li>描述：给定一个迷宫，指明起点和终点，找出从起点出发到终点的有效可行路径。迷宫可以以二维数组来存储表示。0表示通路，1表示障碍。注意这里规定移动可以从上、下、左、右四方方向移动。</li><li>思考：回溯法是根据深度优先的策略进行分析问题的，通俗来说就是，一条路走到死才会回头。为了保证在任何位置上都能沿原路退回，显然需要用一个后进先出的结构来保存从入口到当前位置的路径。因此在求解迷宫通路的算法中需要应用“栈”。<ul><li>首先判断起点和终点是否合法，如果合法则将起点坐标压入栈中，并执行下面的步骤；如果不合法，直接返回，不执行下面的步骤。</li><li>接着，取出栈顶元素，找到该元素可以直接访问的其他坐标中的==一个==，也就是相邻元素，将其压入栈中，并标记为已访问。如果没有相邻未访问元素，则进行回溯，即取出下一个栈顶元素</li><li>重复上一步，知道栈空或者栈顶元素等于终点。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_safe</span>(<span class="hljs-params">maze, x, y</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;检查当前位置是否安全（即是否在迷宫范围内且不是障碍物）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= x &lt; <span class="hljs-built_in">len</span>(maze) <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; <span class="hljs-built_in">len</span>(maze[<span class="hljs-number">0</span>]) <span class="hljs-keyword">and</span> maze[x][y] == <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve_maze</span>(<span class="hljs-params">maze</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;解决迷宫问题的主函数&quot;&quot;&quot;</span><br>    solution = [[<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(maze[<span class="hljs-number">0</span>]) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(maze))]<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> solve_maze_util(maze, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, solution):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有解决方案&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    print_solution(solution)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve_maze_util</span>(<span class="hljs-params">maze, x, y, solution</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;使用回溯法解决迷宫问题的辅助函数&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> x == <span class="hljs-built_in">len</span>(maze) - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> y == <span class="hljs-built_in">len</span>(maze[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>:<br>        solution[x][y] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">if</span> is_safe(maze, x, y):<br>        solution[x][y] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> solve_maze_util(maze, x + <span class="hljs-number">1</span>, y, solution):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <br>        <span class="hljs-keyword">if</span> solve_maze_util(maze, x, y + <span class="hljs-number">1</span>, solution):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        solution[x][y] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_solution</span>(<span class="hljs-params">solution</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;打印迷宫的解决方案&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> solution:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">str</span>(cell) <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row))<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    maze = [<br>        [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>        [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>        [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>        [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>    ]<br>    <br>    solve_maze(maze)<br></code></pre></td></tr></table></figure><h2 id="n后问题">2、n后问题</h2><ul><li><p>描述：在n行n列的国际象棋棋盘上，若两个皇后位于同一行、同一列、同一对角线上，则称它们为互相攻击。找到这n个皇后互不攻击的布局。</p></li><li><p>思考：每个皇后不能再同一列，也就是每个皇后占据一行，根据这个建立解空间树，剪枝条件，两个皇后不能再同一列、同一对角线</p><ul><li><p>n后问题是一个经典的组合优化问题，目标是在 $ n n $ 的棋盘上放置 $n $个皇后，使得它们互不攻击，即任何两个皇后都不在同一行、同一列或同一斜线上。回溯法是解决n后问题的一种有效方法，其基本思想是通过递归地尝试每一种可能的放置方案，直到找到所有可行解或确定无解.</p><ol type="1"><li><strong>问题定义</strong>：<ul><li>棋盘为 $ n n $ 的矩阵，用数组表示每一行皇后的列位置.</li><li>目标是找到一种或多种放置方案，使得所有皇后互不攻击.</li></ul></li><li><strong>回溯法的基本思想</strong>：<ul><li>使用递归函数来遍历所有可能的皇后放置方案.</li><li>在每一步中，尝试将皇后放置在当前行的每一列，并检查是否满足约束条件.</li><li>如果当前放置方案满足约束条件，则继续递归处理下一行；否则，回溯到上一步，尝试其他列.</li></ul></li><li><strong>算法步骤</strong>：<ul><li><strong>初始化</strong>：定义一个数组来存储每一行皇后的列位置，定义一个计数器来记录解的数量.</li><li><strong>递归函数</strong>：<ul><li><strong>参数</strong>：当前行号 $ row $.</li><li><strong>递归终止条件</strong>：<ul><li>如果所有行都已放置完毕，说明找到一个可行解，记录解并返回.</li></ul></li><li><strong>递归扩展</strong>：<ul><li>在当前行的每一列尝试放置皇后.</li><li>检查当前放置是否满足约束条件（不在同一列或同一斜线上）.</li><li>如果满足约束条件，则递归处理下一行.</li></ul></li></ul></li><li><strong>剪枝</strong>：在递归过程中，可以通过剪枝减少不必要的计算.例如，如果当前放置方案已经违反约束条件，则可以立即回溯.</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_safe</span>(<span class="hljs-params">board, row, col, n</span>):<br>    <span class="hljs-comment"># 检查列是否有冲突</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>        <span class="hljs-keyword">if</span> board[i] == col:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 检查左上对角线是否有冲突</span><br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">range</span>(row-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), <span class="hljs-built_in">range</span>(col-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)):<br>        <span class="hljs-keyword">if</span> board[i] == j:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 检查右上对角线是否有冲突</span><br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">range</span>(row-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>), <span class="hljs-built_in">range</span>(col+<span class="hljs-number">1</span>, n)):<br>        <span class="hljs-keyword">if</span> board[i] == j:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve_n_queens</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">row</span>):<br>        <span class="hljs-keyword">if</span> row == n:<br>            <span class="hljs-comment"># 找到一个解</span><br>            result.append(board[:])<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> is_safe(board, row, col, n):<br>                board[row] = col<br>                backtrack(row + <span class="hljs-number">1</span>)<br>                board[row] = -<span class="hljs-number">1</span>  <span class="hljs-comment"># 回溯</span><br><br>    board = [-<span class="hljs-number">1</span>] * n<br>    result = []<br>    backtrack(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-comment"># 示例</span><br>n = <span class="hljs-number">4</span><br>solutions = solve_n_queens(n)<br><span class="hljs-keyword">for</span> solution <span class="hljs-keyword">in</span> solutions:<br>    <span class="hljs-built_in">print</span>(solution)<br>    <br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queen</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-variable language_">self</span>.n = n<br>        <span class="hljs-variable language_">self</span>.x = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 当前解</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>  <span class="hljs-comment"># 当前已找到的可行方案数</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">place</span>(<span class="hljs-params">self, k</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, k):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(k - j) == <span class="hljs-built_in">abs</span>(<span class="hljs-variable language_">self</span>.x[j] - <span class="hljs-variable language_">self</span>.x[k]) <span class="hljs-keyword">or</span> (<span class="hljs-variable language_">self</span>.x[j] == <span class="hljs-variable language_">self</span>.x[k]):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">self, t</span>):<br>        <span class="hljs-keyword">if</span> t &gt; <span class="hljs-variable language_">self</span>.n:<br>            <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">sum</span> += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-variable language_">self</span>.n + <span class="hljs-number">1</span>):<br>                <span class="hljs-variable language_">self</span>.x[t] = i<span class="hljs-comment">#确定第t行的皇后位置为i</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.place(t):<br>                    <span class="hljs-variable language_">self</span>.backtrack(t + <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">n_queen</span>(<span class="hljs-params">n</span>):<br>    q = Queen(n)<br>    q.backtrack(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">sum</span><br><br><span class="hljs-comment"># 示例使用</span><br>n = <span class="hljs-number">4</span><br>solutions = n_queen(n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Number of solutions for <span class="hljs-subst">&#123;n&#125;</span>-queens problem: <span class="hljs-subst">&#123;solutions&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="简单装载问题">3、简单装载问题</h2><ul><li><p>描述：有n个集装箱要装上一艘载重量为W的轮船,其中集装箱i ( 1≤i≤n)的重量为<span class="math inline">\(w_i\)</span>。不考虑集装箱的体积限制,现要这些集装箱中选出若干装上轮船,使它们的重量之和小于等于W 。</p></li><li><p>思考：简单装载问题是指如何将一组物品装入容量有限的容器中，使得容器中的物品总价值最大或总重量不超过容器的容量。回溯法是一种常用的解决此类问题的方法，尤其适用于求解组合优化问题。</p><ol type="1"><li><strong>问题定义</strong>：<ul><li>假设有 $ n $ 个物品，每个物品有一个重量 $ <span class="math inline">\(w_i\)</span> $ 和一个价值 $ <span class="math inline">\(v_i\)</span> $。</li><li>容器的容量为 $ C $。</li><li>目标是选择一些物品放入容器中，使得总重量不超过 $ C $且总价值最大.</li></ul></li><li><strong>回溯法的基本思想</strong>：<ul><li>回溯法通过递归地构建解空间树来寻找最优解。</li><li>解空间树的每个节点代表一个部分解，即当前选择的物品集合.</li><li>从根节点开始，逐步扩展节点，直到找到最优解或确定无解.</li></ul></li><li><strong>算法步骤</strong>：<ul><li><strong>初始化</strong>：定义一个全局变量来存储当前找到的最大价值.</li><li><strong>递归函数</strong>：<ul><li><strong>参数</strong>：当前考虑的物品索引 $ i $，当前总重量 $currentWeight $，当前总价值 $ currentValue $.</li><li><strong>递归终止条件</strong>：<ul><li>如果 $ i $超过物品总数，说明已经考虑完所有物品，此时更新最大价值.</li><li>如果 $ currentWeight $ 超过容器容量 $ C$，则当前部分解无效，直接返回.</li></ul></li><li><strong>递归扩展</strong>：<ul><li><strong>不选择当前物品</strong>：递归处理下一个物品 $ i+1$，保持当前重量和价值不变.</li><li><strong>选择当前物品</strong>：如果当前物品的重量加上当前总重量不超过容器容量，则递归处理下一个物品$ i+1 $，更新当前总重量和价值.</li></ul></li></ul></li><li><strong>剪枝</strong>：在递归过程中，可以通过剪枝减少不必要的计算。例如，如果当前部分解加上剩余物品的最大可能价值仍然小于当前已知的最大价值，则可以剪枝.</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack</span>(<span class="hljs-params">n, C, weights, values</span>):<br>    max_value = [<span class="hljs-number">0</span>]  <span class="hljs-comment"># 全局变量，存储最大价值</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">i, currentWeight, currentValue</span>):<br>        <span class="hljs-keyword">if</span> i == n:<br>            max_value[<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(max_value[<span class="hljs-number">0</span>], currentValue)<br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-comment"># 不选择当前物品</span><br>        backtrack(i + <span class="hljs-number">1</span>, currentWeight, currentValue)<br>        <br>        <span class="hljs-comment"># 选择当前物品</span><br>        <span class="hljs-keyword">if</span> currentWeight + weights[i] &lt;= C:<br>            backtrack(i + <span class="hljs-number">1</span>, currentWeight + weights[i], currentValue + values[i])<br><br>    backtrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> max_value[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 示例</span><br>n = <span class="hljs-number">4</span><br>C = <span class="hljs-number">7</span><br>weights = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>values = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><span class="hljs-built_in">print</span>(knapsack(n, C, weights, values))  <span class="hljs-comment"># 输出最大价值</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">i</span>):<br>    <span class="hljs-comment"># 搜索第i层结点</span><br>    <span class="hljs-keyword">global</span> cw, r, bestw, bestx, x<br>    <span class="hljs-keyword">if</span> i &gt; n:  <span class="hljs-comment"># 到达叶结点</span><br>        <span class="hljs-keyword">if</span> cw &gt; bestw:<br>            bestw = cw<br>            bestx = x[:]<br>        <span class="hljs-keyword">return</span><br>    r -= w[i]<br>    <span class="hljs-keyword">if</span> cw + w[i] &lt;= c:  <span class="hljs-comment"># 搜索左子树</span><br>        x[i] = <span class="hljs-number">1</span><br>        cw += w[i]<br>        backtrack(i + <span class="hljs-number">1</span>)<br>        cw -= w[i]<br>    <span class="hljs-keyword">if</span> cw + r &gt; bestw:  <span class="hljs-comment"># 搜索右子树、剪枝部分</span><br>        x[i] = <span class="hljs-number">0</span><br>        backtrack(i + <span class="hljs-number">1</span>)<br>    r += w[i]<br><br><span class="hljs-comment"># 示例使用</span><br>n = <span class="hljs-number">3</span>  <span class="hljs-comment"># 物品数量</span><br>w = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]  <span class="hljs-comment"># 物品重量</span><br>c = <span class="hljs-number">50</span>  <span class="hljs-comment"># 容器容量</span><br>r = <span class="hljs-built_in">sum</span>(w)  <span class="hljs-comment"># 剩余物品的总重量</span><br>cw = <span class="hljs-number">0</span>  <span class="hljs-comment"># 当前容器的总重量</span><br>bestw = <span class="hljs-number">0</span>  <span class="hljs-comment"># 当前找到的最大重量</span><br>bestx = []  <span class="hljs-comment"># 当前最优解的物品选择状态数组</span><br>x = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 当前解的物品选择状态数组</span><br><br>backtrack(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 从第1个物品开始搜索</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最大装载重量:&quot;</span>, bestw)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最优装载方案:&quot;</span>, bestx[<span class="hljs-number">1</span>:])  <span class="hljs-comment"># 输出最优解的物品选择状态，忽略第0个元素</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="复杂装载问题">4、复杂装载问题</h2><ul><li><p>描述：有一批共n个集装箱要装上2艘载重量分别为<span class="math inline">\(c_1\)</span>和<span class="math inline">\(c_2\)</span>的轮船，其中集装箱i的重量是<span class="math inline">\(w_i\)</span>，且$ _{i=1}^nw_i&lt;=c_1+c_2$，要求找一个合理的装载方案可将集装箱装上这两艘轮船。</p></li><li><p>思考：</p><ul><li><p>当n=3，c1=c2=50 , w={10 , 40 ,40}，将集装箱1和2装到第一艘轮船上,而将集装箱3装到第二艘轮船上。</p></li><li><p>当n=3，c1=c2=50，w={20 , 40 ,40}，则无法将这3个集装箱都装上轮船。</p></li><li><p>首先将第一艘轮船尽可能装满，将剩余的集装箱装上第二艘轮船。将第一艘轮船尽可能装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最接近c1。由此可知，装载问题等价于以下特殊的0-1背包问题。</p></li><li><p>复杂装载问题通常涉及多个容器（如轮船、货车等）和多个物品（如集装箱），目标是将物品合理地分配到各个容器中，以满足一定的约束条件，如容器的容量限制等。回溯法是解决此类问题的一种有效方法，其基本思路是通过递归地构建解空间树来寻找最优解或可行解。</p><h3 id="复杂装载问题的回溯法步骤">复杂装载问题的回溯法步骤</h3><ol type="1"><li><strong>问题定义</strong>：<ul><li>假设有 n 个物品，每个物品有一个重量 $ w_i $。</li><li>有 m 个容器，每个容器有一个容量 <span class="math inline">\(c_j\)</span> 。</li><li>目标是将所有物品分配到这些容器中，使得每个容器的总重量不超过其容量。</li></ul></li><li><strong>回溯法的基本思想</strong>：<ul><li>使用递归函数来遍历所有可能的物品分配方案。</li><li>在每一步中，决定将当前物品放入哪个容器或不放入任何容器。</li><li>使用剪枝技术来减少不必要的计算，提高算法效率。</li></ul></li><li><strong>算法步骤</strong>：<ul><li><strong>初始化</strong>：定义全局变量来存储当前最优解或可行解。</li><li><strong>递归函数</strong>：<ul><li><strong>参数</strong>：当前考虑的物品索引 $ i $，当前容器的重量数组$ currentWeight $，剩余物品的重量和等。</li><li><strong>递归终止条件</strong>：<ul><li>如果所有物品都已分配完毕，检查当前解是否满足所有约束条件，更新最优解或可行解.</li></ul></li><li><strong>递归扩展</strong>：<ul><li><strong>不分配当前物品</strong>：递归处理下一个物品。</li><li><strong>分配当前物品到某个容器</strong>：如果当前物品的重量加上某个容器的当前重量不超过该容器的容量，则将物品放入该容器，并递归处理下一个物品。</li></ul></li></ul></li><li><strong>剪枝</strong>：在递归过程中，可以通过剪枝减少不必要的计算.例如，如果当前部分解加上剩余物品的最大可能重量仍然超过某个容器的容量，则可以剪枝。</li></ul></li></ol><p>假设我们有3个集装箱和2艘轮船，每艘轮船的容量分别为50，集装箱的重量分别为10,40, 40.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">i, currentWeight, remainingWeight</span>):<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(boxes):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(w &lt;= c <span class="hljs-keyword">for</span> w, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(currentWeight, capacities)):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;可行解：&quot;</span>, currentWeight)<br>        <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(capacities)):<br>        <span class="hljs-keyword">if</span> currentWeight[j] + boxes[i] &lt;= capacities[j]:<br>            currentWeight[j] += boxes[i]<br>            backtrack(i + <span class="hljs-number">1</span>, currentWeight, remainingWeight - boxes[i])<br>            currentWeight[j] -= boxes[i]<br>    <br>    backtrack(i + <span class="hljs-number">1</span>, currentWeight, remainingWeight)<br><br><span class="hljs-comment"># 示例</span><br>boxes = [<span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>]<br>capacities = [<span class="hljs-number">50</span>, <span class="hljs-number">50</span>]<br>backtrack(<span class="hljs-number">0</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <span class="hljs-built_in">sum</span>(boxes))<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="背包问题">5、0-1背包问题</h2><ul><li><p>描述：有n个物品，它们有各自的重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？有n种可选物1，…，n，放入容量为c的背包内，背包容量不足以装入所有物品，使装入的物品具有最大效益。</p></li><li><p>思考：0-1背包问题是一个经典的组合优化问题，目标是在不超过背包容量的情况下，从一组物品中选择若干物品放入背包，使得背包中物品的总价值最大。回溯法是一种有效的解决方法，通过递归地尝试每一种可能的物品组合，直到找到最优解.</p><ol type="1"><li><strong>问题定义</strong>：<ul><li>假设有 $ n $ 个物品，每个物品有一个重量 $ w_i $ 和一个价值 $ v_i $.</li><li>背包的容量为 $ C $ .</li><li>目标是选择一些物品放入背包中，使得总重量不超过 $ C $且总价值最大.</li></ul></li><li><strong>回溯法的基本思想</strong>：<ul><li>使用递归函数来遍历所有可能的物品组合.</li><li>在每一步中，决定是否选择当前物品，并检查是否满足约束条件（总重量不超过背包容量）.</li><li>使用剪枝技术来减少不必要的计算，提高算法效率.</li></ul></li><li><strong>算法步骤</strong>：<ul><li><strong>初始化</strong>：定义全局变量来存储当前找到的最大价值和对应的物品选择状态.</li><li><strong>递归函数</strong>：<ul><li><strong>参数</strong>：当前考虑的物品索引 $ i $，当前总重量 $currentWeight $，当前总价值 $ currentValue $ .</li><li><strong>递归终止条件</strong>：<ul><li>如果所有物品都已考虑完毕，更新最大价值和对应的物品选择状态.</li></ul></li><li><strong>递归扩展</strong>：<ul><li><strong>不选择当前物品</strong>：递归处理下一个物品，保持当前重量和价值不变.</li><li><strong>选择当前物品</strong>：如果当前物品的重量加上当前总重量不超过背包容量，则递归处理下一个物品，更新当前总重量和价值.</li></ul></li></ul></li><li><strong>剪枝</strong>：在递归过程中，可以通过剪枝减少不必要的计算.例如，如果当前部分解加上剩余物品的最大可能价值仍然小于当前已知的最大价值，则可以剪枝.</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack_backtrack</span>(<span class="hljs-params">n, C, weights, values</span>):<br>    <span class="hljs-keyword">global</span> max_value, best_solution, current_solution, current_weight, current_value<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">i</span>):<br>        <span class="hljs-keyword">global</span> max_value, best_solution, current_solution, current_weight, current_value<br>        <span class="hljs-keyword">if</span> i == n:<br>            <span class="hljs-keyword">if</span> current_value &gt; max_value:<br>                max_value = current_value<br>                best_solution = current_solution[:]<br>            <span class="hljs-keyword">return</span><br>        <br>        <span class="hljs-comment"># 不选择当前物品</span><br>        backtrack(i + <span class="hljs-number">1</span>)<br>        <br>        <span class="hljs-comment"># 选择当前物品</span><br>        <span class="hljs-keyword">if</span> current_weight + weights[i] &lt;= C:<br>            current_solution[i] = <span class="hljs-number">1</span><br>            current_weight += weights[i]<br>            current_value += values[i]<br>            backtrack(i + <span class="hljs-number">1</span>)<br>            current_solution[i] = <span class="hljs-number">0</span><br>            current_weight -= weights[i]<br>            current_value -= values[i]<br>    <br>    max_value = <span class="hljs-number">0</span><br>    best_solution = [<span class="hljs-number">0</span>] * n<br>    current_solution = [<span class="hljs-number">0</span>] * n<br>    current_weight = <span class="hljs-number">0</span><br>    current_value = <span class="hljs-number">0</span><br>    <br>    backtrack(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> max_value, best_solution<br><br><span class="hljs-comment"># 示例</span><br>n = <span class="hljs-number">4</span><br>C = <span class="hljs-number">7</span><br>weights = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>values = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>max_value, best_solution = knapsack_backtrack(n, C, weights, values)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最大价值: <span class="hljs-subst">&#123;max_value&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最优解: <span class="hljs-subst">&#123;best_solution&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="批处理作业调度问题">6、批处理作业调度问题</h2><ul><li>描述：给定n个作业的集合<span class="math inline">\({J_1,J_2,…,J_n}\)</span>。每个作业必须先由机器1处理，然后由机器2处理。作业<span class="math inline">\(J_i\)</span>需要机器j的处理时间为<span class="math inline">\(t_{ji}\)</span>。对于一个确定的作业调度，设Fji是作业i在机器j上完成处理的时间。所有作业在机器2上完成处理的时间和称为该作业调度的完成时间和。批处理作业调度问题要求对于给定的n个作业，制定最佳作业调度方案，使其完成时间和达到最小。</li><li>思考：批处理作业调度是要从n个作业的所有排列中找出有最小完成时间和的作业调度，所以批处理调度问题的解空间是一棵排列树。按照回溯法搜索排列树的算法框架，设开始时x= [1, .., n]是所给的 <strong>n</strong> 个作业，则相应的排列树由所有排列构成。<img src="/2025/01/07/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-5/image-20250107202508939.png" alt="image-20250107202508939" style="zoom:50%;"></li></ul><h2 id="符号三角形问题">7、符号三角形问题</h2><ul><li>描述：由14个“+”和14个“-”组成的符号三角形。2个同号下面都是“+”，2个异号下面都是“-”。符号三角形的第一行有n个符号。符号三角形问题要求对于给定的n，计算有多少个不同的符号三角形，使其所含的“+”和“-”的个数相同。</li><li>思考：不断改变第一行每个符号，搜索符合条件的解，可以使用递归回溯。<ul><li>为了便于运算，设+为0，-为1，这样可以使用异或运算符表示符号三角形的关系。</li><li>因为两种符号个数相同，可以对题解树剪枝，当所有符号总数为奇数时无解，当某种符号超过总数一半时无解。</li><li>当第一行的前 $ i $ 个符号 $ x[1:i] $ 确定后，可以构造一个包含 $i(i+1)/2 $ 个符号的符号三角形.这是因为符号三角形的每一行符号数量依次递增，形成一个等差数列，其前 $ i $行的符号总数为 $ i(i+1)/2 $.</li><li>当确定了 $ x[i+1] $的值后，可以在已确定的符号三角形的右边加一条边，从而拓展为 $ x[1:i+1] $所对应的符号三角形.这一步是回溯法中的递归扩展过程，通过增加一个符号来扩展当前的解空间.</li><li><strong>约束条件</strong>：<ul><li>符号三角形中“+”和“-”的个数必须相等，即都为 $ n(n+1)/4 $.这是因为符号三角形的总符号数为 $ n(n+1)/2$，一半的符号为“+”，另一半为“-”.</li><li>如果 $ n(n+1)/2 $为奇数，则不存在满足条件的符号三角形，因为奇数不能被均匀分成两部分.</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Backtrack</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-keyword">global</span> count, half, <span class="hljs-built_in">sum</span>, n, p<br>    <span class="hljs-keyword">if</span> count &gt; half <span class="hljs-keyword">or</span> (t * (t + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> - count) &gt; half:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> t &gt; n:<br>        <span class="hljs-built_in">sum</span> += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):  <span class="hljs-comment"># 分别给 0, 1</span><br>            p[<span class="hljs-number">1</span>][t] = i<br>            count += i<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, t + <span class="hljs-number">1</span>):  <span class="hljs-comment"># 下面每一排数据</span><br>                p[j][t - j + <span class="hljs-number">1</span>] = p[j - <span class="hljs-number">1</span>][t - j + <span class="hljs-number">1</span>] ^ p[j - <span class="hljs-number">1</span>][t - j + <span class="hljs-number">2</span>]<br>                count += p[j][t - j + <span class="hljs-number">1</span>]<br>            Backtrack(t + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, t + <span class="hljs-number">1</span>):<br>                count -= p[j][t - j + <span class="hljs-number">1</span>]<br>            count -= i<br><br><span class="hljs-comment"># 初始化全局变量</span><br>n = <span class="hljs-number">4</span>  <span class="hljs-comment"># 例如，n=4</span><br>half = n * (n + <span class="hljs-number">1</span>) // <span class="hljs-number">4</span><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>count = <span class="hljs-number">0</span><br>p = [[<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]  <span class="hljs-comment"># 初始化符号三角形数组</span><br><br>Backtrack(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Number of valid symbol triangles: <span class="hljs-subst">&#123;<span class="hljs-built_in">sum</span>&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机算法-4</title>
    <link href="/2025/01/04/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-4/"/>
    <url>/2025/01/04/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-4/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法">贪心算法</h1><ul><li><p>什么是贪心算法？</p><ul><li>在对问题求解时，总是做出在当前看来是最好的选择，就是贪心。不从整体上最优加以考虑，所做出的仅是在某种意义上的局部最优。</li><li>贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题，它能产生==整体最优解或者是整体最优解的近似解==。</li><li>特点：多步判断、最优子结构性质、贪心选择性质</li></ul></li><li><p>最优化问题</p><ul><li>每个最优化问题包含一组限制条件和一个优化函数<ul><li>可行解：符合限制条件的问题求解方案</li><li>最优解：使优化函数取得最佳解的可行解</li></ul></li></ul></li><li><p>动态规划 VS 贪心算法</p><ul><li><p>共同点：都要求问题具有最优子结构性质</p></li><li><p>动态规划：自底向上，求解出很多子问题，然后再做出选择</p></li><li><p>贪心算法：自顶向下，第一步为贪心选择，将原问题变成一个相似的、但规模更小的问题，而后每一步都是当前看似最佳的选择。从求解的全过程来看，每一次贪心选择都将当前问题归纳为更小的相似子问题，而每一次选择都仅做一次，无重复回溯过程，具有较高的时间效率。</p><p><img src="/2025/01/04/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-4/image-20250105205422424.png" alt="image-20250105205422424" style="zoom:50%;"></p></li></ul></li></ul><h2 id="范例">1、范例</h2><h3 id="最短路径">1、最短路径</h3><ul><li>描述：寻找初始点到达目标点的最短路径</li><li>思考：每一步在路径中添加一个顶点，假设当前路径中已到达顶点P，且顶点P并不是目标顶点，则选择离P最近且目前不在路径中的点</li></ul><h3 id="渴婴问题">2、渴婴问题</h3><ul><li>描述：婴儿可得到n种不同的饮料。根据以前关于这n种饮料的不同体验，此婴儿知道这其中某些饮料更合自己的胃口，因此，婴儿采取如下方法为每一种饮料赋予一个满意度值：饮用1盎司第i种饮料，对它作出相对评价，将一个数值<span class="math inline">\(s_i\)</span>作为满意度赋予第i种饮料。这个婴儿都会尽量饮用具有最大满意度值的饮料来最大限度地满足她解渴地需要，但是不幸地是：具有最大满意度值地饮料有时并没有足够地量来满足此婴儿解渴地需要。设<span class="math inline">\(a_i\)</span>是第i种饮料地总量，而此婴儿需要t盎司的饮料来解渴，那么，需要饮用n种不同的饮料各多少量才能满足婴儿解渴的需求。</li><li>思考：只考虑局部最优，选择后不能进行更改。因此将饮料的满意度按照从大到小进行排序，按顺序喝即可</li></ul><h3 id="装载问题">3、装载问题</h3><ul><li>描述：有一艘大船准备用来装载货物。所有待装货物都装在货箱中且所有货箱的大小都一样，但货箱的重量都各不相同。设第i个货箱的重量为<span class="math inline">\(w_i\)</span>（1≤i≤n），而货箱的最大载重量为c，目的：在货船上更多的货物。</li><li>思考：将货物按照从小到大进行排序，按顺序载入船中</li></ul><h2 id="活动安排问题">2、活动安排问题</h2><ul><li>描述：在所给的活动集合中选出一个最大相容的活动子集合。}设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源（如一个阶梯教室等），而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间<span class="math inline">\(s_i\)</span>和一个结束时间<span class="math inline">\(f_i\)</span>，且<span class="math inline">\(0&lt;=s_i&lt;f_i&lt;0\)</span>。如果选择了活动i，则它在半开时间区间<span class="math inline">\([s_i, f_i)\)</span>内占用资源;若区间<span class="math inline">\([s_i, f_i)\)</span>与区间<span class="math inline">\([s_j,f_j)\)</span>不相交，则称活动i与活动j是相容的。也就是说，当<span class="math inline">\(s_i≥f_j\)</span>或<span class="math inline">\(s_j≥f_i\)</span>时，活动i与活动j相容。</li><li>思考：对于这个问题来说，当一个活动结束时间越早，对后面的活动来说越好。当选择第一个活动时，选择结束时间最早的活动，这样对于后面的活动来说更好进行选择；在选择第二个活动时，同样选择当前结束时间最早的活动。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">activity_selection</span>(<span class="hljs-params">activities</span>):<br>    <span class="hljs-comment"># 按活动结束时间排序</span><br>    activities.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br>    <span class="hljs-comment"># 选择第一个活动</span><br>    selected_activities = [activities[<span class="hljs-number">0</span>]]<br>    last_end_time = activities[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 遍历剩余的活动</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(activities)):<br>        <span class="hljs-keyword">if</span> activities[i][<span class="hljs-number">0</span>] &gt;= last_end_time:<br>            selected_activities.append(activities[i])<br>            last_end_time = activities[i][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> selected_activities<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 活动列表，每个活动用 (开始时间, 结束时间) 表示</span><br>    activities = [(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">6</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">8</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">9</span>), (<span class="hljs-number">6</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">8</span>, <span class="hljs-number">11</span>), (<span class="hljs-number">8</span>, <span class="hljs-number">12</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">13</span>), (<span class="hljs-number">12</span>, <span class="hljs-number">14</span>)]<br>    selected_activities = activity_selection(activities)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;选择的活动:&quot;</span>, selected_activities)<br></code></pre></td></tr></table></figure><h2 id="背包问题组合优化问题">3、背包问题：组合优化问题</h2><ul><li>描述：有一个贼在偷窃一家商店时发现有N件物品；第i件物品值<span class="math inline">\(p_i\)</span>元，重<span class="math inline">\(w_i\)</span>磅（1≤i≤N），且都是整数。他希望带走的东西越值钱越好，但他的背包中最多能装下M磅的东西（整数）。</li></ul><p><img src="/2025/01/04/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-4/image-20250105212412323.png" alt="image-20250105212412323" style="zoom:50%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fractional_knapsack</span>(<span class="hljs-params">capacity, weights, values</span>):<br>    <span class="hljs-comment"># 计算每个物品的单位重量价值</span><br>    item_values = [(values[i] / weights[i], weights[i], values[i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weights))]<br>    <span class="hljs-comment"># 按单位重量价值从高到低排序</span><br>    item_values.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>], reverse=<span class="hljs-literal">True</span>)<br>    total_value = <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">for</span> value_per_weight, weight, value <span class="hljs-keyword">in</span> item_values:<br>        <span class="hljs-keyword">if</span> capacity &gt;= weight:<br>            <span class="hljs-comment"># 如果背包容量大于等于物品重量，全部装入</span><br>            capacity -= weight<br>            total_value += value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 否则，装入部分物品</span><br>            total_value += value_per_weight * capacity<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> total_value<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机算法-3</title>
    <link href="/2024/12/29/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-3/"/>
    <url>/2024/12/29/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-3/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划">动态规划</h1><blockquote><p>基本思想：将待求解问题分解成若干子问题，先求解子问题，再结合这些子问题的解得到原问题的解，这一点与分治思想类似。但是，使用动态规划算法求解的问题经过分解得到的子问题==往往不是相互独立的==.也就是子问题求解时存在重叠。动态规划是一个用来解决==多段决策过程最优==的通用方法。==在动态规划算法，多阶段决策过程，每步求解的问题都是后面阶段求解问题的子问题，每部决策将依赖于以前步骤的决策==。</p><p>在分治法中，会造成分解得到的子问题过多，导致解决原问题要耗费的时间非常多，而且相同的子问题会被==重复多次计算==。如果能够保存已求得的解，就可以避免重复的大量计算。因此可以使用一个表进行记录已解决的问题答案，这是动态规划的基本思想。同时使用动态规划的问题应具有最优子结构性质（==即最优解包含子问题的最优解==）</p><p>如：在计算斐波那契数列时，<span class="math inline">\(fib(5)=fib(4)+fib(3)=(fib(3)+fib(2))+(fib(2)+fib(1))\)</span>多次计算<span class="math inline">\(fib(2)\)</span></p><p>当前问题满足优化原则时，使用动态规划来设计算法。所谓优化原则，就是一个最优决策序列的任何子序列本身一定是相对于子序列的初始和结束状态的最优的决策序列。</p></blockquote><p>通俗来说，动态规划的优化原则可以概括为以下几点：</p><ol type="1"><li><p><strong>分而治之</strong>：将一个复杂的问题分解成一系列更小的子问题，这些子问题通常被称为“状态”。每个状态对应于问题的一个特定阶段或部分。</p></li><li><p><strong>最优子结构</strong>：一个问题的最优解包含其子问题的最优解。这意味着，如果你能解决子问题，就能通过某种方式组合这些子问题的解来解决整个问题。</p></li><li><p><strong>重叠子问题</strong>：在递归解决子问题的过程中，相同的子问题会被多次求解。动态规划通过存储这些子问题的解（通常是在表格或数组中），避免重复计算，从而提高效率。</p></li><li><p><strong>记忆化</strong>：在递归过程中，每当解决一个子问题，就将其结果存储起来（这个过程称为“记忆化”）。当再次遇到相同的子问题时，直接使用存储的结果，而不是重新计算。</p></li><li><p><strong>自底向上</strong>：动态规划通常采用自底向上的方法，即从最简单的子问题开始解决，逐步构建到复杂问题的解。这与分治法的自顶向下的方法不同。</p></li><li><p><strong>状态转移方程</strong>：动态规划问题通常有一个或多个状态转移方程，这些方程定义了如何从一个或多个状态的解构建出新状态的解。</p></li><li><p><strong>边界条件</strong>：在动态规划中，需要明确定义问题的边界条件，即最简单的子问题的解。这些边界条件是构建整个问题解的基础。</p></li></ol><p>动态规划算法适用于解最优化问题，步骤设计：</p><ul><li>找出最优解的性质，并刻画其结构特征</li><li>递归地定义最优值</li><li>以自底向上的方式计算最优值，记录构造最优解所必需的信息</li><li>根据计算最优值得到的结构，构造最优解</li></ul><h2 id="范例斐波那契数列">1、范例：斐波那契数列</h2><p>斐波那契数列是一个经典的动态规划问题。斐波那契数列的定义是：F(0) = 0,F(1) = 1, 且对于n &gt; 1, F(n) = F(n-1) + F(n-2)。</p><ol type="1"><li>识别问题的结构</li></ol><p>斐波那契数列具有重叠子问题和最优子结构的特性。计算F(n)需要知道F(n-1)和F(n-2)，而计算F(n-1)又需要知道F(n-2)和F(n-3)，以此类推。</p><ol start="2" type="1"><li>定义状态</li></ol><p>定义状态F(n)为斐波那契数列的第n项。</p><ol start="3" type="1"><li>确定状态转移方程</li></ol><p>状态转移方程为：F(n) = F(n-1) + F(n-2)。</p><ol start="4" type="1"><li>确定边界条件</li></ol><p>边界条件为：F(0) = 0, F(1) = 1。</p><ol start="5" type="1"><li>选择计算顺序</li></ol><p>我们可以选择自底向上的迭代方法来计算斐波那契数列。</p><ol start="6" type="1"><li>实现算法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        dp = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n+<span class="hljs-number">1</span>):<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>提取最终解</li></ol><p>最终解是<span class="math inline">\(dp[n]\)</span>，即斐波那契数列的第n项。</p><h2 id="矩阵链乘法">2、矩阵链乘法</h2><ul><li>描述：给定n个矩阵的链&lt;<span class="math inline">\(A_1\)</span>,<span class="math inline">\(A_2\)</span>,……，<span class="math inline">\(A_n\)</span>&gt;，其中<span class="math inline">\(A_i\)</span>与<span class="math inline">\(A_{i+1}\)</span>是是可乘的，矩阵<span class="math inline">\(A_i\)</span>的维数为1<span class="math inline">\(P_i \timesP_i\)</span>，如何确定计算矩阵的乘积的计算次序（完全括号化方式），使得依次次序计算矩阵链的乘积需要的次数最少</li><li>思考：设<span class="math inline">\(A[i:j]\)</span>表示<span class="math inline">\(A_i\)</span>到<span class="math inline">\(A_j\)</span>的连续矩阵相乘的计算量，如果计算<span class="math inline">\(A[i:j]\)</span>的最优计算量，可以将这个计算次序在<span class="math inline">\(A[k]\)</span>与<span class="math inline">\(A[k+1]\)</span>之间进行断开，<span class="math inline">\(A[i:j]\)</span>的计算量可以表示为<span class="math inline">\(A[i:k]\)</span>的计算量加上<span class="math inline">\(A[k+1:j]\)</span>的计算量，再加上<span class="math inline">\(A[i:k]\)</span>与<span class="math inline">\(A[k+1:j]\)</span>相乘的计算量。</li></ul><ol type="1"><li><p><strong>定义问题</strong>：设<span class="math inline">\(A_i\)</span>的维度为<span class="math inline">\(p_{i-1} \timesp_i\)</span>，我们需要找到一个完全括号化的方式，使得计算<span class="math inline">\(A_1A_2...A_n\)</span>的乘法次数最少。</p></li><li><p><strong>状态定义</strong>：定义<span class="math inline">\(m[i][j]\)</span>为计算<span class="math inline">\(A[i:j]\)</span>（即从第<span class="math inline">\(i\)</span>个矩阵到第<span class="math inline">\(j\)</span>个矩阵的乘积）的最小乘法次数。</p></li><li><p><strong>状态转移方程</strong>：对于<span class="math inline">\(i\leq k &lt; j\)</span>，我们可以在<span class="math inline">\(A_k\)</span>和<span class="math inline">\(A_{k+1}\)</span>之间断开，那么<span class="math inline">\(m[i][j]\)</span>可以表示为： $ m[i][j] = <em>{i k&lt; j} (m[i][k] + m[k+1][j] + p</em>{i-1}p_kp_j) $ 其中，<span class="math inline">\(m[i][k]\)</span>是计算<span class="math inline">\(A[i:k]\)</span>的最小乘法次数，<span class="math inline">\(m[k+1][j]\)</span>是计算<span class="math inline">\(A[k+1:j]\)</span>的最小乘法次数，<span class="math inline">\(p_{i-1}p_kp_j\)</span>是将<span class="math inline">\(A[i:k]\)</span>和<span class="math inline">\(A[k+1:j]\)</span>相乘的乘法次数。</p></li><li><p><strong>边界条件</strong>：当<span class="math inline">\(i =j\)</span>时，即只有一个矩阵，不需要乘法，所以<span class="math inline">\(m[i][i] = 0\)</span>。</p></li><li><p><strong>计算顺序</strong>：我们从最小的子问题开始，即先计算<span class="math inline">\(m[i][i+1]\)</span>，然后是<span class="math inline">\(m[i][i+2]\)</span>，以此类推，直到计算出<span class="math inline">\(m[1][n]\)</span>，即整个矩阵链的最小乘法次数。</p></li><li><p><strong>构造解</strong>：在计算<span class="math inline">\(m[i][j]\)</span>的同时，我们还需要记录最优断开点<span class="math inline">\(k\)</span>，以便最后能够构造出最优的完全括号化方式。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#利用递归实现，存在大量重复计算，比如函数中计算的当前状态下最优的t并未保存下来</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">i:<span class="hljs-built_in">int</span>,j:<span class="hljs-built_in">int</span>,lst:<span class="hljs-built_in">list</span>,matrix:<span class="hljs-built_in">list</span></span>)-&gt;<span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    i:用于记录矩阵序号</span><br><span class="hljs-string">    j:用于记录矩阵序号</span><br><span class="hljs-string">    lst:用于记录最优分割点</span><br><span class="hljs-string">    matrix:记录矩阵维数的列表</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> i==j:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    u=fun(i,j,<span class="hljs-built_in">list</span>,matrix)+fun(i+<span class="hljs-number">1</span>,j,lst,matrix)+matrix[i-<span class="hljs-number">1</span>]*matrix[i]*matrix[j]<br>    lst[i][j]=i<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> (i+<span class="hljs-number">1</span>,j):<br>        t=fun(i,k,lst,matrix)+fun(k+<span class="hljs-number">1</span>,j,lst,matrix)+matrix[i-<span class="hljs-number">1</span>]*matrix[k]*matrix[j]<br>        <span class="hljs-keyword">if</span> t&lt;u:<br>            u=t<br>            lst[i][j]=k<br><span class="hljs-keyword">return</span> u<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#去除递归，记录已经计算得到的结果</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">p:<span class="hljs-built_in">list</span></span>)-&gt;<span class="hljs-built_in">list</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    p:记录各个矩阵维数的列表</span><br><span class="hljs-string">    m:列表，用于记录当前最优的分割点</span><br><span class="hljs-string">    s:列表，用于记录当前最优的相乘次数</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment">#初始化</span><br>    n=<span class="hljs-built_in">len</span>(p)-<span class="hljs-number">1</span> <span class="hljs-comment">#矩阵数量</span><br>    m=[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    s=[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<span class="hljs-comment">#用于表示当前考虑的矩阵链长度，最短是2</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-l+<span class="hljs-number">1</span>):<span class="hljs-comment">#用于表示矩阵链的起始位置</span><br>            j=i+l-<span class="hljs-number">1</span><span class="hljs-comment">#这是当前矩阵链的结束位置</span><br>            m[i][j]=<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<span class="hljs-comment">#初始化当前子问题的最优解，初始为正无穷</span><br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i,j):<span class="hljs-comment">#用于表示分割点位置</span><br>                q=m[i][k]+m[k+<span class="hljs-number">1</span>][j]+p[i]*p[k+<span class="hljs-number">1</span>]*p[j-<span class="hljs-number">1</span>]<span class="hljs-comment">#计算当前分割点的矩阵链乘数</span><br>                <span class="hljs-keyword">if</span> q&lt;m[i][j]:<span class="hljs-comment">#判断是否更优</span><br>                    m[i][j]=q<br>                    s[i][j]=k<br>    <span class="hljs-keyword">return</span> m,s<br></code></pre></td></tr></table></figure><h2 id="最长公共子序列">3、最长公共子序列</h2><ul><li>描述：字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列X=“<span class="math inline">\(x_0，x_1，…，x_{m-1}\)</span>”，序列Y=“<span class="math inline">\(y_0，y_1，…，y_{k-1}\)</span>”是X的子序列，存在X的一个严格递增下标序列<span class="math inline">\(&lt;i_0，i_1，…，i_{k-1}&gt;\)</span>，使得对所有的<span class="math inline">\(j=0，1，…，k-1\)</span>，有<span class="math inline">\(x_{ij}\)</span>=<span class="math inline">\(y_j\)</span>。例如，X=“ABCBDAB”，Y=“BCDB”是X的一个子序列。给定一个序列Z，该序列既是Y的子序列，又是X的子序列，称Z是X和Y的公共子序列。</li><li>思考：求两个数组<span class="math inline">\(A[n]\)</span>和<span class="math inline">\(B[m]\)</span>的最长公共子序列，可以自底而上地进行考虑。举例，当这两个数组的长度为0时，则最长公共子序列为0，使用<span class="math inline">\(M[0][0]\)</span>进行记录；当A数组长度为1，数组长度为0时，使用<span class="math inline">\(M[1][0]\)</span>进行记录。已知无论哪个数组长度为0时，这个的最长公共子序列都为0，因此<span class="math inline">\(M[0][y]=0\)</span>，<span class="math inline">\(M[x][0]=0\)</span>；当数组长度都为1时，此时<span class="math inline">\(M[1][0]\)</span>和<span class="math inline">\(M[0][1]\)</span>已知，只需要比较<span class="math inline">\(A[1]\)</span>和<span class="math inline">\(B[1]\)</span>是否相等，相等则加1，不相等则加0，因此<span class="math inline">\(M[1][1]=max(M[0][1],M[1],[0])+1或0\)</span></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">A:<span class="hljs-built_in">list</span>,B:<span class="hljs-built_in">list</span></span>)-&gt;<span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    A,B：传入的两个一维数组</span><br><span class="hljs-string">    M：用于记录当前最优解</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment">#初始化M</span><br>    M=[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(B))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A))]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(A)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(B)):<br>            <span class="hljs-keyword">if</span> A[i]==B[j]:<br>                M[i][j]=<span class="hljs-built_in">max</span>(M[i-<span class="hljs-number">1</span>][j],M[i][j-<span class="hljs-number">1</span>])+<span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                M[i][j]=<span class="hljs-built_in">max</span>(M[i-<span class="hljs-number">1</span>][j],M[i][j-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> M[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    A=[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br>    B=[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br>    <span class="hljs-built_in">print</span>(fun(A,B)) <br></code></pre></td></tr></table></figure><h2 id="最大子段和">4、最大子段和</h2><ul><li><p>描述：给定由n个整数(可能为负整数)组成的序列<span class="math inline">\(a_1,a_2,…,a_n\)</span>，求该序列形如<span class="math inline">\(\sum_{n=i}^ja_n\)</span>的子段和的最大值。当所有和为负整数时定义其最大子段和为0。</p></li><li><p>思考：自底而上，m用于表示子段结束位置。假设数组A长度为2，当m=0时，当前子段只有一个数，使用<span class="math inline">\(M[0]\)</span>记录当前值作为当前子段和最优解；当m=1时，使用<span class="math inline">\(M[1]\)</span>记录当前子段的最优解，<span class="math inline">\(M[1]=max(A[0],M[0]+A[1])\)</span>。</p></li><li><p>疑问：为什么是<span class="math inline">\(M[1]=max(A[0],M[0]+A[1])\)</span>而不是<span class="math inline">\(M[1]=max(M[0],M[0]+A[1])\)</span>？</p><ul><li><p>对于每个元素<span class="math inline">\(a_i\)</span>，我们有两种选择：要么将<span class="math inline">\(a_i\)</span>加入到前一个子段中，要么从<span class="math inline">\(a_i\)</span>开始一个新的子段。因此，<span class="math inline">\(M[i]\)</span>的值应该是这两种选择中的最大值。</p><p>具体来说，对于<span class="math inline">\(M[1]\)</span>的计算，我们有以下两种情况：</p><ol type="1"><li>从<span class="math inline">\(a_0\)</span>开始的子段加上<span class="math inline">\(a_1\)</span>，即<span class="math inline">\(M[0] +a_1\)</span>。</li><li>从<span class="math inline">\(a_1\)</span>开始一个新的子段，即<span class="math inline">\(a_1\)</span>本身。</li></ol><p>因此，<span class="math inline">\(M[1]\)</span>的值应该是这两种情况中的最大值，即<span class="math inline">\(M[1] = \max(a_1, M[0] + a_1)\)</span>。</p><p>所以，<span class="math inline">\(M[1] = \max(A[0], M[0] +A[1])\)</span>是正确的，因为它考虑了从<span class="math inline">\(a_1\)</span>开始新子段的情况和将<span class="math inline">\(a_1\)</span>加入到以<span class="math inline">\(a_0\)</span>结尾的子段中的情况。而<span class="math inline">\(M[1] = \max(M[0], M[0] +A[1])\)</span>是错误的，因为它没有考虑从<span class="math inline">\(a_1\)</span>开始新子段的情况，只考虑了将<span class="math inline">\(a_1\)</span>加入到以<span class="math inline">\(a_0\)</span>结尾的子段中的情况。</p><p>因此，正确的表达式是<span class="math inline">\(M[1] = \max(A[0],M[0] + A[1])\)</span>。</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">nums:<span class="hljs-built_in">list</span></span>)-&gt;<span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    maxSum:用于记录全局最优解</span><br><span class="hljs-string">    current：用于记录当前最优解</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    maxSum=nums[<span class="hljs-number">0</span>]<br>    current=nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        current=<span class="hljs-built_in">max</span>(nums[i],nums[i]+current)<br>        maxSum=<span class="hljs-built_in">max</span>(maxSum,current)<br>    reuturn maxSum<br><br><span class="hljs-comment">#记录最优解的起始位置</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">nums: <span class="hljs-built_in">list</span></span>) -&gt; <span class="hljs-built_in">tuple</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    maxSum: 用于记录全局最优解</span><br><span class="hljs-string">    current: 用于记录当前最优解</span><br><span class="hljs-string">    start: 当前子段的起始位置</span><br><span class="hljs-string">    end: 当前子段的结束位置</span><br><span class="hljs-string">    temp_start: 临时起始位置，用于更新start</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    maxSum = nums[<span class="hljs-number">0</span>]<br>    current = nums[<span class="hljs-number">0</span>]<br>    start = <span class="hljs-number">0</span><br>    end = <span class="hljs-number">0</span><br>    temp_start = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">if</span> nums[i] &gt; nums[i] + current:<br>            current = nums[i]<br>            temp_start = i<br>        <span class="hljs-keyword">else</span>:<br>            current += nums[i]<br><br>        <span class="hljs-keyword">if</span> current &gt; maxSum:<br>            maxSum = current<br>            start = temp_start<br>            end = i<br><br>    <span class="hljs-keyword">return</span> maxSum, start, end<br></code></pre></td></tr></table></figure><p>注：该问题可以使用顺序求和、分治法、动态规划等算法进行解决</p><h2 id="背包问题">5、0-1背包问题</h2><ul><li><p>描述：有n个物品，它们有各自的重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？有n种可选物1，…，n，放入容量为c的背包内，背包容量不足以装入所有物品，使装入的物品具有最大效益。</p></li><li><p>思考：</p><ul><li>有 $ n $ 个物品，每个物品的重量为 $ w_i $，价值为 $ v_i $。</li><li>背包的重量限制为 $ W $。</li><li>求解在重量限制 $ W $ 内，背包中可以装入的物品的最大价值。</li></ul><ol type="1"><li><strong>定义状态</strong>：<ul><li>==令 $ dp[i][j] $ 表示前 $ i $ 个物品中，总重量不超过 $ j $时的最大价值==。</li></ul></li><li><strong>状态转移方程</strong>：<ul><li>对于第 $ i $ 个物品，有两种选择：装入背包或不装入背包。</li><li>如果不装入背包，那么 <span class="math inline">\(dp[i][j]=dp[i-1][j]\)</span>。</li><li>如果装入背包，那么 $ dp[i][j] = dp[i-1][j-w_i] + v_i $（前提是 $ jw_i $）。</li><li>因此，状态转移方程为： $ dp[i][j] = (dp[i-1][j], dp[i-1][j-w_i] +v_i) j w_i $ $ dp[i][j] = dp[i-1][j] j &lt; w_i $</li></ul></li><li><strong>初始化</strong>：<ul><li>$dp[0][j] = 0 $对于所有 $ j $，表示没有物品时，任何重量的背包价值为0。</li><li>$dp[i][0] = 0 $对于所有 <span class="math inline">\(i\)</span>，表示重量为 0的背包，无论有多少物品，价值为 0。</li></ul></li><li><strong>计算顺序</strong>：<ul><li>按照 $ i $ 从 1 到 $ n $，对于每个 $ i $，按照 $ j $ 从 0 到 $ W $计算 $ dp[i][j] $。</li></ul></li><li><strong>最终答案</strong>：<ul><li>最大价值为 $ dp[n][W] $。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">knapsack</span>(<span class="hljs-params">W, weights, values</span>):<br>    n = <span class="hljs-built_in">len</span>(weights)<br>    dp = [[<span class="hljs-number">0</span>] * (W + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(W + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j &gt;= weights[i-<span class="hljs-number">1</span>]:<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-weights[i-<span class="hljs-number">1</span>]] + values[i-<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">else</span>:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]<br>    <br>    <span class="hljs-keyword">return</span> dp[n][W]<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机算法-2</title>
    <link href="/2024/12/27/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-2/"/>
    <url>/2024/12/27/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-2/</url>
    
    <content type="html"><![CDATA[<h1 id="递归与分治">递归与分治</h1><h2 id="一递归">一、递归</h2><h3 id="阶乘函数">1、阶乘函数</h3><blockquote><p>递归基本思想：直接或间接调用自身的算法称为递归算法</p></blockquote><ol type="1"><li>阶乘函数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> n * factorial(n-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>阶乘函数的尾递归版本</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n, acc=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> acc<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> factorial(n-<span class="hljs-number">1</span>, acc*n)<br></code></pre></td></tr></table></figure><h3 id="斐波那契数列">2、斐波那契数列</h3><ol type="1"><li>斐波那契数列</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> fibonacci(n-<span class="hljs-number">1</span>) + fibonacci(n-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>计算斐波那契数列的尾递归版本 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n, a=<span class="hljs-number">0</span>, b=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> a<br>    <span class="hljs-keyword">elif</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> b<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> fibonacci(n-<span class="hljs-number">1</span>, b, a+b)<br></code></pre></td></tr></table></figure></li></ol><h3 id="排列问题">3、排列问题</h3><ul><li>描述：对数组中的元素进行全排列</li><li>思考：对一个长度为n的数组进行排序，相当于将这个数组中的每一个元素分别提取出来，再将剩下的元素进行全排列。也就是说，将每一个元素提取出来放在数组的最前面，剩下的元素再进行全排列。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Perm</span>(<span class="hljs-params">nums:<span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>],l:<span class="hljs-built_in">int</span>,r:<span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-literal">None</span>:  <span class="hljs-comment"># noqa: E741</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    nums:用于存放数组</span><br><span class="hljs-string">    l:是数组的左边界，会变化，要进行交换的位置</span><br><span class="hljs-string">    r：是数组的右边界</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> l==r:<br>        <span class="hljs-built_in">print</span>(nums)<br>    <span class="hljs-keyword">else</span>:<br>        i=l<br>        <span class="hljs-keyword">while</span>(i&lt;=<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># //交换位置</span><br>            swap(nums,l,i)<br>            <span class="hljs-comment"># //进行递归</span><br>            Perm(nums,l+<span class="hljs-number">1</span>,r)<br>            swap(nums,l,i)<br>            i+=<span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">nums,a,b</span>):<br>    temp=nums[b]<br>    nums[b]=nums[a]<br>    nums[a]=temp<br>nums=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>Perm(nums,l=<span class="hljs-number">0</span>,r=<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h3 id="整数划分问题">4、整数划分问题</h3><ul><li>描述：将一个整数划分成一系列整数的和</li><li>思考：这是一个双递归函数。在正整数n的所有划分中，将最大加数<span class="math inline">\(n_1\)</span>不大于m的划分个数记作<span class="math inline">\(q(n,m)\)</span></li></ul><p><span class="math display">\[q(n,m)=\begin{cases}1,&amp;\text{n=1,m=1}\\q(n,n),&amp;\text{n&lt;m}\\1+q(n,n-1),&amp;\text{n=m}\\q(n,m-1)+q(n-m,m),&amp;\text{n&gt;m&gt;1}\end{cases}\]</span></p><p>根据n和m的关系，考虑以下几种情况： 1.当n=1时，不论m的值为多少（m&gt;0)，只有一种划分即{1}; 2.当m=1时，不论n的值为多少，只有一种划分即n个1，{1,1,1,...,1}; 3.当n=m时，根据划分中是否包含n，可以分为两种情况： 1.划分中包含n的情况，只有一个即{n}； 2.划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有(n-1)划分。因此 f(n,n) =1 + f(n,n-1); 4.当n&lt;m时，由于划分中不可能出现负数，因此就相当于f(n,n); 5.但n&gt;m时，根据划分中是否包含最大值m，可以分为两种情况： 1.划分中包含m的情况，即{m, {x1,x2,...xi}}, 其中{x1,x2,... xi}的和为n-m，因此这情况下为f(n-m,m) 2.划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1);因此 f(n, m) = f(n-m, m)+f(n,m-1);</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">q</span>(<span class="hljs-params">n:<span class="hljs-built_in">int</span>,m:<span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">if</span> n&lt;<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> m&lt;<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> n==<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> m==<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> n==m:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+q(n,n-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">elif</span> n&lt;m:<br>        <span class="hljs-keyword">return</span> q(n,n)<br>    <span class="hljs-keyword">elif</span> n&gt;m:<br>        <span class="hljs-keyword">return</span> q(n,m-<span class="hljs-number">1</span>)+q(n-m,m)<br></code></pre></td></tr></table></figure><blockquote><p>递归算法的优点：结构清晰，可读性强，而且容易使用数学归纳法来证明算法的正确性。</p><p>递归算法的缺点：算法的运行效率较低，时间和空间消耗都比非递归算法要多。</p></blockquote><h2 id="二分治">二、分治</h2><blockquote><p>基本思想：将一个规模为n的问题分解为k个规模较小的子问题，这些子问题相互独立且与原问题相同，通过递归解决这些子问题，然后将各个子问题的解合并得到原问题的解。</p><p>分割原则：</p><ul><li>如何对原问题进行分割？<ul><li>在实践中发现，在使用分治法设计算法时，最好使得子问题的规模大致相同</li></ul></li></ul></blockquote><h3 id="棋盘覆盖算法">1、棋盘覆盖算法</h3><ul><li>描述：在一个<span class="math inline">\(2^k \times2^k\)</span>个方格组成的棋盘中，有一个方格与其他方格不同，则称该方格为一个特殊方格，且称该棋盘为一个特殊棋盘。在棋盘覆盖问题中，要用的4种不同形态的L型骨牌覆盖一个给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。易知，在任何一个<span class="math inline">\(2^k \times2^k\)</span>的棋盘覆盖中，用到的L型骨牌个数恰为<span class="math inline">\((4^k-1)/3\)</span>。</li><li>思考：面对一个<span class="math inline">\(2^k \times2^k\)</span>个方格组成的棋盘，将其分成四个等大的小棋盘，如果存在一个特殊方格在一个小棋盘上，则将这个L型的骨牌覆盖其他三个小棋盘。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">ti = <span class="hljs-number">0</span>  <span class="hljs-comment"># 骨牌编号</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">tr, tc, dr, dc, size</span>):<br>    <span class="hljs-keyword">global</span> ti, matrix<br>    <span class="hljs-keyword">if</span> size == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span>  <span class="hljs-comment"># 当棋盘分割到1x1时终止递归</span><br>    <span class="hljs-keyword">else</span>:<br>        s = size // <span class="hljs-number">2</span>  <span class="hljs-comment"># 分割棋盘</span><br>        ti += <span class="hljs-number">1</span>  <span class="hljs-comment"># 对骨牌进行编号</span><br>        t=ti<br>        <span class="hljs-comment"># 检查特殊方块在哪个子棋盘</span><br>        <span class="hljs-keyword">if</span> dr &lt; tr + s <span class="hljs-keyword">and</span> dc &lt; tc + s:  <span class="hljs-comment"># 左上子棋盘</span><br>            func(tr, tc, dr, dc, s)<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 左上子棋盘放置L型骨牌</span><br>            matrix[tr + s - <span class="hljs-number">1</span>][tc + s - <span class="hljs-number">1</span>] = t<br>            func(tr, tc, tr + s - <span class="hljs-number">1</span>, tc + s - <span class="hljs-number">1</span>, s)<br>        <span class="hljs-keyword">if</span> dr &lt; tr + s <span class="hljs-keyword">and</span> dc &gt;= tc + s:  <span class="hljs-comment"># 右上子棋盘</span><br>            func(tr, tc + s, dr, dc, s)<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 右上子棋盘放置L型骨牌</span><br>            matrix[tr + s - <span class="hljs-number">1</span>][tc + s] = t<br>            func(tr, tc + s, tr + s - <span class="hljs-number">1</span>, tc + s, s)<br>        <span class="hljs-keyword">if</span> dr &gt;= tr + s <span class="hljs-keyword">and</span> dc &lt; tc + s:  <span class="hljs-comment"># 左下子棋盘</span><br>            func(tr + s, tc, dr, dc, s)<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 左下子棋盘放置L型骨牌</span><br>            matrix[tr + s][tc + s - <span class="hljs-number">1</span>] = t<br>            func(tr + s, tc, tr + s, tc + s - <span class="hljs-number">1</span>, s)<br>        <span class="hljs-keyword">if</span> dr &gt;= tr + s <span class="hljs-keyword">and</span> dc &gt;= tc + s:  <span class="hljs-comment"># 右下子棋盘</span><br>            func(tr + s, tc + s, dr, dc, s)<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 右下子棋盘放置L型骨牌</span><br>            matrix[tr + s][tc + s] = t<br>            func(tr + s, tc + s, tr + s, tc + s, s)<br>matrix = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>)]<br>func(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>)<br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> matrix:<br>    <span class="hljs-built_in">print</span>(row)<br></code></pre></td></tr></table></figure><h3 id="线性时间选择">2、线性时间选择</h3><ul><li>描述：在n个元素的无序数组中选择第k小元素<ul><li>当k=1时，相当于找最小值</li><li>当k=n时，相当于找最大值</li><li>当k=<span class="math inline">\(\frac{n}{2}\)</span>时，相当于找中值</li></ul></li><li>想法：对于这个数组进行以下处理<ul><li>首先进行分组，将数组中的元素每五个划分成一个数组，当单个数组中元素数量小于6时直接进行排序</li><li>对每个数组找出其中的中位数，并将所有中位数写到一个数组中，再递归找出这个由中位数组成的数组的中位数，经过这一步也就找到了原数组的中位数</li><li>根据这个中位数，对原数组进行简单的划分，分成三部分，小于中位数，等于中位数，大于中位数</li><li>通过判断k在哪一部分进行舍弃，就是小于中位数的数组长度与k进行比较</li><li>留下来的部分再重复上述步骤</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 递归找到中间元素</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_median</span>(<span class="hljs-params">sublists</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sublists) &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> sublists[<span class="hljs-number">0</span>][<span class="hljs-built_in">len</span>(sublists[<span class="hljs-number">0</span>]) // <span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">else</span>:<br>        medians = [sublists[i][<span class="hljs-built_in">len</span>(sublists[i]) // <span class="hljs-number">2</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(sublists))]<br>        <span class="hljs-keyword">return</span> find_median([medians[i:i + <span class="hljs-number">5</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(medians), <span class="hljs-number">5</span>)])<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">nums, k</span>): <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">6</span>:<br>        temp = <span class="hljs-built_in">sorted</span>(nums)<br>        <span class="hljs-keyword">return</span> temp[k - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">else</span>:<br>        sublists = [nums[i:i + <span class="hljs-number">5</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums), <span class="hljs-number">5</span>)]<span class="hljs-comment">#将数组进行划分</span><br>        <span class="hljs-comment"># 对每组元素进行排序</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(sublists)):<br>            sublists[i] = <span class="hljs-built_in">sorted</span>(sublists[i])<br>        <span class="hljs-comment"># 获取其中间元素的中间元素</span><br>        result2 = find_median(sublists)<br>        <span class="hljs-comment"># 通过比较进行舍取</span><br>        less_than_pivot = [num <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums <span class="hljs-keyword">if</span> num &lt; result2]<br>        equal_to_pivot = [num <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums <span class="hljs-keyword">if</span> num == result2]<br>        greater_than_pivot = [num <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums <span class="hljs-keyword">if</span> num &gt; result2]<br>        <span class="hljs-keyword">if</span> k &lt;= <span class="hljs-built_in">len</span>(less_than_pivot):<br>            <span class="hljs-keyword">return</span> find(less_than_pivot, k)<br>        <span class="hljs-keyword">elif</span> k &lt;= <span class="hljs-built_in">len</span>(less_than_pivot) + <span class="hljs-built_in">len</span>(equal_to_pivot):<br>            <span class="hljs-keyword">return</span> result2 <br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> find(greater_than_pivot, k - <span class="hljs-built_in">len</span>(less_than_pivot) - <br>                        <span class="hljs-built_in">len</span>(equal_to_pivot))<br></code></pre></td></tr></table></figure><h3 id="二分搜索术">3、二分搜索术</h3><ul><li>描述：将n个元素分成个数大致相同的两半，取a[n/2]与x作比较。如果x=a[n/2]，则算法终止；如果x&lt;a[n/2]，则只在数组a的左半部继续搜索x；如果x&gt;a[n/2]，则只在数组a的右半部继续搜索x。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">nums:<span class="hljs-built_in">list</span>,x:<span class="hljs-built_in">int</span>,l:<span class="hljs-built_in">int</span>,r:<span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-built_in">bool</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    nums:数组列表</span><br><span class="hljs-string">    x:目标搜索对象</span><br><span class="hljs-string">    l:左边界</span><br><span class="hljs-string">    r:右边界</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> l&gt;r:<br>        <span class="hljs-keyword">return</span> false<br>    <span class="hljs-keyword">else</span>:<br>        mid=(l+r)//<span class="hljs-number">2</span><span class="hljs-comment">#计算中间坐标</span><br>        <span class="hljs-keyword">if</span> nums[mid]==x:<br>            <span class="hljs-keyword">return</span> true<br>        <span class="hljs-keyword">elif</span> nums[mid]&lt;x:<br>            <span class="hljs-keyword">return</span> fun(nums,x,mid+<span class="hljs-number">1</span>,r)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> fun(nums,x,l,mid-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="循环赛日程表">4、循环赛日程表</h3><ul><li>描述：<ul><li>要求设计一个满足以下要求的比赛日程表<ul><li>共有n个选手，n=2<sup>m</sup></li><li>每个选手必须与其他n-1个选手各赛一次</li><li>每个选手一天只能赛一次</li><li>循环赛一共进行n-1天</li></ul></li></ul></li></ul><p><span class="math display">\[\begin{matrix}1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8 \\2&amp;1&amp;4&amp;3&amp;6&amp;5&amp;8&amp;7 \\3&amp;4&amp;1&amp;2&amp;7&amp;8&amp;5&amp;6 \\4&amp;3&amp;2&amp;1&amp;8&amp;7&amp;6&amp;5 \\5&amp;6&amp;7&amp;8&amp;1&amp;2&amp;3&amp;4 \\6&amp;5&amp;8&amp;7&amp;2&amp;1&amp;4&amp;3\\7&amp;8&amp;5&amp;6&amp;3&amp;4&amp;1&amp;2\\8&amp;7&amp;6&amp;5&amp;4&amp;3&amp;1&amp;2\\\end{matrix}\tag{1}\]</span></p><ul><li>思考：<ul><li>通过矩阵可知：<ul><li>大矩阵是通过左上、右下、右上、左下四个小矩阵组成，左上=右下，右上=左下</li><li>可以将第一行看做选手编号</li><li>第i+1行可以看做第i天该选手对战的选手编号</li><li><span class="math inline">\(matrix[i+1][j]\)</span>的值表示第i天选手j对战的选手编号</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">m=<span class="hljs-number">5</span><br>matrix=[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**m)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**m)]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loop_schedule</span>(<span class="hljs-params">row,col,<span class="hljs-built_in">len</span></span>):<br>    <span class="hljs-keyword">global</span> matrix<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span> == <span class="hljs-number">1</span>:<br>        matrix[<span class="hljs-number">0</span>][col]=<span class="hljs-number">1</span>+col<br>        <span class="hljs-keyword">return</span> <br>    <span class="hljs-comment">#处理左上角和右下角</span><br>    loop_schedule(<span class="hljs-number">0</span>,col,<span class="hljs-built_in">len</span>//<span class="hljs-number">2</span>)<br>    <span class="hljs-comment">#处理右上角和左下角</span><br>    loop_schedule(<span class="hljs-number">0</span>,col+<span class="hljs-built_in">len</span>//<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>//<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>//<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>//<span class="hljs-number">2</span>):<br>            matrix[<span class="hljs-built_in">len</span>//<span class="hljs-number">2</span>+i][col+j]=matrix[i][col+<span class="hljs-built_in">len</span>//<span class="hljs-number">2</span>+j]<br>            matrix[<span class="hljs-built_in">len</span>//<span class="hljs-number">2</span>+i][col+<span class="hljs-built_in">len</span>//<span class="hljs-number">2</span>+j]=matrix[i][col+j]<br>            <br>loop_schedule(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>**m)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**m):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**m):<br>        <span class="hljs-built_in">print</span>(matrix[i][j],end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br><br></code></pre></td></tr></table></figure><h2 id="三扩展">三、扩展</h2><h3 id="寻找超级水王">1、寻找超级水王</h3><ul><li>描述：在某一论坛中存在某一个ID，该ID发帖数量超过帖子总数的一半，称这个ID为水王。如何找出这个ID？通俗讲，就是一个数组中存在某个数字占该数组长度的一半以上。</li><li>思考：由于水王数的个数大于所有元素个数的一半，所以如果拿一个非水王数抵消一个水王数，最后还是会剩下水王数。上述删除不同元素的过程就是如此，还可能会存在两个非水王数互相抵消的情况，这样水王数剩下的会更多。</li><li>步骤：<ul><li>使用变量分别存放候选水王数，以及候选水王数的已遍历过的个数<ul><li>变量一candidate作为候选用来存放可能的水王数</li><li>变量二hp用来存放其剩余个数，按如下规则遍历数组：<ul><li>hp=0 代表没有candidate候选数；hp&gt;0 代表有candidate候选数</li><li>如果没有candidate，则设置当前数赋予candidate，即将当前数作为候选数，hp设置为1</li><li>如果有candidate，判断当前数是否等于candidate，相等则hp+1，不相等则hp-1</li></ul></li></ul></li><li>依次删除数组中的两个不相同的数</li><li>判断是否存在数剩余：如果存在数剩余，则水王存在；反之，水王不存在。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">nums</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    nums:数组</span><br><span class="hljs-string">    candidate:当前候选水王</span><br><span class="hljs-string">    hp:候选水王的个数，当hp=0时，对candidate重新赋值</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment">#初始化candidate</span><br>    candidate=nums[<span class="hljs-number">0</span>]<br>    hp=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>        <span class="hljs-keyword">if</span> hp==<span class="hljs-number">0</span>:<br>            candidate=i<br>            hp+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> i!=candidate:<br>            hp-=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            hp+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> hp==<span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;没有水王&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;水王是：<span class="hljs-subst">&#123;candidate&#125;</span>&#x27;</span>)<br>            <br>nums = [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<br>fun(nums)<br></code></pre></td></tr></table></figure><h3 id="超级水王进阶">2、超级水王进阶</h3><ul><li>描述：随着Tango的发展，管理员发现，“超级水王”没有了。统计结果表明，有3个发帖很多的ID，他们的发帖数目都超过了帖子总数目N的1/4。你能从发帖ID列表中快速找出他们的ID吗？</li><li>思考：<ul><li>有三个水王，每个水王的ID出现次数超过四分之一</li><li>因此使用三个变量记录当前遍历过的不同的三个ID，同时记录在这三个ID出现的次数</li><li>在遍历过程中，如果出现不同于当前记录的这三个ID的其他ID时，分别查看这三个ID出现次数，如果这三个ID中存在次数为0的ID，则将该ID替换为当前遍历到的ID。如果这三个ID均不为0，则每个ID出现次数-1</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">nums:<span class="hljs-built_in">list</span></span>)-&gt;<span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    nums:ID列表</span><br><span class="hljs-string">    lst：三行两列数组，一行用于存放ID，一行用于存放ID出现次数</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    lst=[[<span class="hljs-literal">None</span>,<span class="hljs-number">0</span>],[<span class="hljs-literal">None</span>,<span class="hljs-number">0</span>],[<span class="hljs-literal">None</span>,<span class="hljs-number">0</span>]]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>        <span class="hljs-keyword">if</span> lst[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==i:<br>            lst[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> lst[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]==i:<br>            lst[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> lst[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]==i:<br>            lst[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> lst[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> lst[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]!=i <span class="hljs-keyword">and</span> lst[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]!=i:<br>            lst[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=i<br>            lst[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> lst[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> lst[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]!=i <span class="hljs-keyword">and</span> lst[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]!=i:<br>            lst[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=i<br>            lst[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> lst[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> lst[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]!=i <span class="hljs-keyword">and</span> lst[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]!=i:<br>            lst[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=i<br>            lst[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> lst[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==i:<br>            lst[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> nums:<br>            lst[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]-=<span class="hljs-number">1</span><br>            lst[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-=<span class="hljs-number">1</span><br>            lst[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]-=<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(lst)<br><br>nums=[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>fun(nums)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归 分zhi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机算法-1</title>
    <link href="/2024/12/25/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-1/"/>
    <url>/2024/12/25/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-1/</url>
    
    <content type="html"><![CDATA[<h1 id="算法效率基础">算法效率基础</h1><p><strong>算法分析是对算法需要多少计算时间和存储空间作定量的分析,因此算法的复杂性存在空间复杂性和时间复杂性两个方面。算法的复杂性是算法运行需要的计算机资源的量。</strong></p><h2 id="影响算法复杂性的因素">1. 影响算法复杂性的因素</h2><ol type="1"><li>要解的问题的规模：问题本身</li><li>算法的输入：要处理的数据</li><li>算法本身的函数：处理问题的方法</li></ol><h2 id="元运算">2. 元运算</h2><blockquote><p>对任何计算步骤，他的代价总是一个时间常量为上界，不管数据输入或执行的算法，我们称该步骤为“元运算”。通俗讲就是时间固定</p></blockquote><blockquote><p>举例：访问数组中的一个元素就是一个“元运算”，因为不管你的数组有多大，访问任何一个特定位置的元素所需的时间都是相同的，这个时间是一个常数，不会随着数组大小的变化而变化。</p></blockquote><h2 id="如何度量运行时间即算法的时间复杂度">3.如何度量运行时间（即算法的时间复杂度）</h2><blockquote><p>用算法的基本操作的执行次数来度量算法的时间效率</p></blockquote><blockquote><p>所谓的基本操作，就是指算法中最基本的操作，比如：赋值、比较、输入输出等。</p></blockquote><h2 id="算法复杂性符号表示">4. 算法复杂性符号表示</h2><ol type="1"><li>Θ：是渐进紧确界记号，当且仅当<span class="math inline">\(\lim\limits_{n\rightarrow\infty}\frac{f(n)}{g(n)}\)</span>存在并等于一个常数，那么f(n)=Θ(g(n))。也就是f(n)和g(n)同阶。</li><li>O：是渐进上界记号，当存在正整数c和<span class="math inline">\(n_0\)</span>，使得当n&gt;=<span class="math inline">\(n_0\)</span>时，f(n)&lt;=cg(n)。则f(n)的渐进上界是g(n),f(n)=O(g(n))。通俗说当n在一定范围内时，函数f(n)的阶不高于函数g(n)。g(n)的阶越低越精确。</li><li>Ω：是渐进下界记号，当存在正整数c和<span class="math inline">\(n_0\)</span>，使得当n&gt;=<span class="math inline">\(n_0\)</span>时，f(n)&gt;=cg(n)。则f(n)的渐进下界是g(n),f(n)=O(g(n))。通俗说当n在一定范围内时，函数f(n)的阶不低于函数g(n)。g(n)的阶越高越精确。<img src="/2024/12/25/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-1/image.png" alt="&#39;图片1&#39;"> ## 5.如何分析非递归算法效率</li><li>找出算法的基本操作</li><li>检查基本操作的执行次数是否只依赖输入规模</li><li>建立一个算法基本操作执行次数的求和表达式 ## 6.如何分析递归算法效率</li><li>找出递归的边界条件,一般而言递归的边界条件是n=1，而且是进行切半的操作。<span class="math display">\[T(n)=\begin{cases}O(1),&amp;\text{n=1}\\kT(n/2)+O(1),&amp;\text{n&gt;1}\end{cases}\]</span></li><li>分析递归式的解法</li><li>计算递归式的解法的执行次数</li><li>建立递归式的解法的执行次数的求和表达式（注：递归算法代码简洁，但是效率低下） ## 7. 主定理解决递归效率问题</li></ol><ul><li>主定理提供一个通用的方法来解决形如<span class="math inline">\(T(n)=aT(n/b)+f(n)\)</span>的递归式的效率问题。</li></ul><ol type="1"><li>n：是问题的规模</li><li>a：是原问题的子问题个数</li><li><span class="math inline">\(\frac{n}{b}\)</span>：是子问题的规模大小</li><li>f(n)：是将原问题分解成子问题和将子问题的解合并成原问题的解的时间<img src="/2024/12/25/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95-1/image-1.png" alt="alt text"></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法效率分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/12/25/hello-world/"/>
    <url>/2024/12/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
